
# // Copyright 2024.
# // Distributed under the Boost Software License, Version 1.0.
# // (See accompanying file LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt)

import subprocess
import argparse
import re
import sys
import shutil

LLVM_OBJDUMP = "llvm-objdump"
LLVM_MCA = "llvm-mca"

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def run_llvm_objdump(file, symbols, cpu):
    EXTRA_ARGS = ["-d", "--no-addresses", "--no-show-raw-insn", "--symbolize-operands", "--disassembler-color=off"]
    args = [LLVM_OBJDUMP, *EXTRA_ARGS, file]

    if len(symbols) > 0:
        args.append(f"--disassemble-symbols={','.join(symbols)}")
    if cpu is not None:
        args.append(f"--mcpu={cpu.lower()}")

    return subprocess.run(args, capture_output=True, text=True)

def run_llvm_mca(
    assembly, syntax, all_stats, all_views, timeline, iterations, cpu, show_encoding, timeline_max_iterations, timeline_max_cycles
):
    args = [LLVM_MCA]

    if syntax == 'intel':
        args.append("-output-asm-variant=1")
    elif syntax == 'at&t':
        args.append("-output-asm-variant=0")
    else:
        raise ValueError("syntax is not 'intel' or 'at&t'")
    
    if all_stats:
        args.append("-all-stats")
    if all_views:
        args.append("-all-views")
    if timeline:
        args.append("-timeline")
    if iterations is not None:
        args.append(f"-iterations={iterations}")
    if cpu is not None:
        args.append(f"-mcpu={cpu.lower()}")
    if show_encoding:
        args.append("-show-encoding")
    if timeline_max_iterations is not None:
        args.append(f"-timeline-max-iterations={timeline_max_iterations}")
    if timeline_max_cycles is not None:
        args.append(f"-timeline-max-cycles={timeline_max_cycles}")

    return subprocess.run(args, input=assembly, encoding='ascii', capture_output=True, text=True)

def string_split_args(val):
    return [s.strip() for s in val.split(",")]

def main():
    parser = argparse.ArgumentParser(description=
        "Runs 'llvm-mca' over compiled binary file.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("file",
        help="File to disassemble."
    )
    parser.add_argument("-s", "--symbols", type=string_split_args, default=[],
        help="Disassemble only the specified symbols."
    )
    parser.add_argument("--syntax", choices=["intel", "at&t"], default="intel",
        help="Specify the output assembly variant for the report generated by the tool."
    )
    parser.add_argument("--timeline", "--show-timeline", action="store_true", default=False,
        help=TIMELINE_HELP
    )
    parser.add_argument("--all-stats", "--show-all-stats", action="store_true", default=False,
        help="Print all hardware statistics. This enables extra statistics related to the dispatch logic, the hardware schedulers, the register file(s), and the retire control unit."
    )
    parser.add_argument("--all-views", "--show-all-views", action="store_true", default=False,
        help="Enable all the view."
    )
    parser.add_argument("--iterations", default=None,
        help="Specify the number of iterations to run."
    )
    parser.add_argument("--cpu", default=None,
        help="Specify the processor for which to analyze the code. By default, the cpu name is autodetected from the host."
    )
    parser.add_argument("--encoding", "--show-encoding", action="store_true", default=False,
        help="Enable the printing of instruction encodings within the instruction info view."                    
    )
    parser.add_argument("--timeline-max-iterations", default=1,
        help="Limit the number of iterations to print in the timeline view."                    
    )
    parser.add_argument("--timeline-max-cycles", default=None,
        help="Limit the number of cycles in the timeline view, or use 0 for no limit."                    
    )

    args = parser.parse_args()

    try:
        output = run_llvm_objdump(args.file, args.symbols, args.cpu)
    except FileNotFoundError:
        eprint(f"Tool '{LLVM_OBJDUMP}' not found")
        sys.exit(1)

    if output.returncode != 0:
        eprint(f"Failed to run 'llvm-objdump': {output.stderr}")
        sys.exit(1)
    
    if len(output.stderr) > 0:
        print(output.stderr)

    clean_assembly = re.sub("[<>]", "", output.stdout)

    try:
        analyzed_output = run_llvm_mca(clean_assembly,
            args.syntax, args.all_stats, args.all_views, args.timeline, args.iterations, args.cpu, args.encoding, args.timeline_max_iterations, args.timeline_max_cycles
        )
    except FileNotFoundError:
        eprint(f"Tool '{LLVM_MCA}' not found")
        sys.exit(1)
    
    if analyzed_output.returncode != 0:
        eprint(f"Failed to run 'llvm-mca': {analyzed_output.stderr}")
        sys.exit(1)

    print(analyzed_output.stdout)

TIMELINE_HELP = """Shows timeline view.
D : Instruction dispatched.
e : Instruction executing.
E : Instruction executed.
R : Instruction retired.
= : Instruction already dispatched, waiting to be executed.
- : Instruction executed, waiting to be retired."""

if __name__ == "__main__":
    main()

